{"name":"Plasmidjs","tagline":"Plasmidjs allows you to treat an object as cell and each of its methods as genes; allowing you to control which methods/genes are switched on,","body":"##Plasmidjs\r\n\r\nPlasmidjs allows you to treat an object as a cell and each of its methods as genes allowing you to control which methods/genes are switched on, and what happens if an *switched-off* method is called.\r\n\r\nThis is the child of synthetic biology and nodejs and was inspired by the author's experience at Cooper Union's Summer STEM iGem track as well as by [conduitjs](https://github.com/ifandelse/ConduitJS).\r\n\r\n## Background\r\n\r\nSynthetic biology is defined as:\r\n> an interdisciplinary branch of biology, combining disciplines such as biotechnology, evolutionary biology, molecular biology, systems biology, biophysics, computer engineering, and is in many ways related to genetic engineering.\r\n\r\nSynthetic biologists study the construction of new biological mechanisms and ways to optimize their design and development. More specifically, synthetic biologists can design custom DNA and insert it into a cell to engineer organisms to their liking and solve many of the world's problems.\r\n\r\nUsually, the type of DNA used is a plasmid â€“ hence the name *Plasmidjs* . After DNA insertion, the cell begins to express whichever functions are encoded by the genes in this DNA. Sometimes, it is necessary that only certain genes be activated at a time. This feat is accomplished by the use of a special part of DNA called a promoter which can switch genes on and off.\r\n\r\nVery simply, the promoter is either induced or repressed. If it is repressed, the gene it controls is not expressed. If it is induced, the gene it controls is expressed.\r\n\r\n## So what?\r\n\r\nConcepts from synthetic biology provide the perfect metaphor for a javascript library that enables you to switch on and off object functions.\r\n\r\n```javascript\r\nvar plasmid = require('plasmidjs')\r\n\r\nvar organism = {\r\n    height: 50,\r\n    grow: function(){\r\n        this.height+=3\r\n        return this.height\r\n    },\r\n\r\n    ideas: [\r\n        \"never let your schooling interfere with your eduction\",\r\n        \"you dont get what you don't ask for\",\r\n        \"be persistent\",\r\n        \"take advantage of the fact you exist\",\r\n        \"automate things\"\r\n    ],\r\n    think: function(){\r\n        return this.ideas.pop() || \"I'm all out of ideas\"\r\n    },\r\n\r\n    position: {x: 0, y: 0},\r\n    walk: function(x, y){\r\n        this.position.x = x\r\n        this.position.y = y\r\n        return this.position\r\n    }\r\n}\r\n\r\n/*\r\n * Create our plasmid\r\n *\r\n */\r\nvar cell = plasmid.Promote( organism )\r\n\r\n\r\n```\r\nStart simple\r\n\r\n```javascript\r\ncell.think() //=> \"never let your schooling interfere with your eduction\"\r\n\r\n/*\r\n * Turn a gene off\r\n */\r\ncell.think.repress()() //=> undefined\r\n\r\n/*\r\n * Turn a gene on\r\n */\r\ncell.think.induce()()//=> \"you dont get what you don't ask for\"\r\n\r\n```\r\n\r\nLet's get complicated\r\n\r\n```javascript\r\n\r\n/*\r\n * Only one gene is on.\r\n */\r\ncell.only('grow').think()//=> undefined\r\ncell.induced()//=> ['grow']\r\ncell.repressed()//=> ['think','walk']\r\ncell.grow()//=> 53\r\n\r\n/*\r\n * Turning all genes on\r\n */\r\ncell.all(true).think()//=> \"be persistent\"\r\n\r\n/*\r\n * All genes except walk\r\n */\r\ncell.except('walk').grow()//=> undefined\r\ncell.walk(20,15)//=> {x: 20, y:15}\r\n```\r\n\r\nHopefully you're impressed.\r\n\r\n## Docs\r\n\r\nThe module is broken into two parts: `Plasmid`, which wraps an entire object, and `Gene` which wraps each function of the newly created plasmid object. Methods can be repressed and induced. When induced, genes perform as expected i.e, mimicking the behavior of the function they wrap. When repressed, genes do nothing at all or perform whichever behavior is specified by their failure function.\r\n\r\n+ Plasmid\r\n  + `var obj = new plasmid.Plasmid( old_obj[,options])`\r\n  + `obj.fail( failure_func )`\r\n  + `obj.all( state )`\r\n  + `obj.only( method, ... `)\r\n  + `obj.except( method, ... )`\r\n  + `obj.induced()`\r\n  + `obj.repressed()`\r\n\r\n+ Gene\r\n  + `var gene = new plasmid.Gene( function[,options])`\r\n  + `gene.connect( matcher, responder)`\r\n  + `gene.induce()`\r\n  + `gene.repress()`\r\n  + `gene.fail( failure_func )`\r\n  + `gene.induced()`\r\n  + `gene.repressed()`\r\n\r\n##Plasmid\r\n### var obj = new plasmid.Plasmid( target, [options])\r\n\r\nCreates a new plasmid that wraps `target`. Note: creating a new plasmid will not modify the original object. Instead, the module creates a new object with the plasmid instance functions as well as the wrapped object's own functions, that when called execute with the `this` context of the wrapped object.\r\n\r\n`old_obj`: the object to wrap\r\n`options`: an optional options object with the following (all optional) fields:\r\n```javascript\r\n    {\r\n        exposed: [\"method\", [ \"another method\"]],\r\n        induced: <true | false>\r\n    }\r\n```\r\n`options.exposed`: and array containing the names of the functions of the target that should be wrapped.\r\n`options.induced`: whether the wrapped methods should start induced. Otherwise, they are repressed. Defaults to true.\r\n\r\n```\r\n\r\n\r\n\r\n```\r\n\r\n### obj.fail( failure_func )\r\n\r\nPass a failure function to be called when any repressed method is called. Under the hood, it uses `gene.failure`\r\n\r\n```javascript\r\ncell.fail( function(method_name, args{\r\n   /*----( Your code here )----*/\r\n})\r\n\r\n```\r\n\r\n### obj.all( true | false )\r\nSet the state of all genes\r\n`true`: induced\r\n`false`: repressed\r\n**Returns** the plasmid object, for chaining\r\n\r\n### obj.only( method, ... )\r\n\r\nInduce the genes specified by their name\r\n**Returns** the plasmid object, for chaining\r\n\r\n### obj.except( method, ... )\r\n\r\nTurn every gene on except for those specified by their name\r\n**Returns** the plasmid object, for chaining\r\n\r\n### obj.induced()\r\n\r\nReturns an array of induced genes\r\n\r\n### obj.repressed()\r\n\r\nReturns an array of repressed genes\r\n\r\n##Gene\r\n\r\nGenes wrap regular functions in `Gene` instances that can be switched on and off with ease.\r\n\r\n### var gene = new plasmid.Gene( function, [options])\r\n\r\nWraps a function in a gene instance function, allowing you to add meta-functionality to the original function.\r\n\r\nOptions:\r\n\r\n```javascript\r\n{\r\n  context: object,\r\n  name: the name of the gene,\r\n  induced: < true | false >,\r\n\r\n}\r\n```\r\n\r\n`context` the object in whose context to run the wrapped function,\r\n`name`: the name of the gene, used to identify it as well as when failure functions are called\r\n`induced`: whether the gene should start as being induced.\r\n\r\n### gene.connect( matcher, responder)\r\n\r\nSConnects a matcher function to a specific responder, allowing you to very easily determine which function should handle a specific instance of arguments. Note: the responder will be called instead of the regular gene function.\r\n\r\n```javascript\r\n\r\nfunction matchStr(a){\r\n  return typeof a === 'string'\r\n}\r\n\r\nvar insert = {\r\n\r\n    mirror: function(arg){\r\n        // args = Array.prototype.slice.call(arguments, 0)\r\n        // return args\r\n        return arg\r\n    }\r\n}\r\n\r\nvar recombinant = plasmid.assemble(insert)\r\nvar string = \"old eagles only order out\"\r\nvar integer = 42\r\n\r\nrecombinant.mirror.connect(matchStr, function(a){\r\n  console.log(\"Handling string: \", string)\r\n  return \"mirrored STRING\"\r\n})\r\n\r\nrecombinant.mirror.connect(matchNum, function(a){\r\n    console.log(\"Handling number: \", a)\r\n    return \"mirrored INTEGER\"\r\n})\r\n\r\n/*\r\n * Look below\r\n */\r\n recombinant.mirror(\"Hello\")//=>\"Hello\"\r\nrecombinant.mirror(string)//=>  \"mirrored STRING\"\r\nrecombinant.mirror(integer)//=> \"mirrored INTEGER\"\r\n\r\n```\r\n\r\n### gene.induce()\r\n\r\nTurn the gene one\r\n\r\n### gene.repress()\r\n\r\nTurn the gene off\r\n\r\n### gene.fail\r\n\r\nCalled when the gene function is invoked while simultaneously being repressed. Whatever the failure function returns will be returned when the repressed gene is invoked.\r\n\r\n```javascript\r\n\r\nfunction hello(thing){\r\n  return \"Hello, \" + thing\r\n}\r\n\r\nvar hi = new plasmid.Gene(hello, {name: \"hello\"})\r\nhi('world')//=> \"Hello, world\"\r\n\r\nhi.fail(function(function_name, arguments){\r\n\r\n  return \"Function \" + function_name + \"failed with: \" + arguments.toString()\r\n\r\n})\r\n\r\nhi.repress()('bob')//=> \"Function hello failed with: 'bob'\"\r\n\r\n```\r\n\r\n### gene.induced()\r\n\r\n**Returns** whether the gene is induced\r\n\r\n### gene.repressed()\r\n\r\n**Returns** whether the gene is repressed\r\n\r\n\r\n## Contributions\r\n\r\nYes! Contribute!\r\n\r\nOn a more serious note, I would like to see plasmidjs become the de-facto module for meta - functions. I'd like to add the ability to create waterfalls of async and sync functions, add pre and post gene invocation functions, typecheckers, more complex state management capablities, etc.\r\n\r\nIf you have any ideas, please submit a pull request or file an issue explaining your idea and I'll do my best to add it.\r\n\r\n\r\n\r\n\r\n-------------\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2015 Akiva Lipshitz\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}